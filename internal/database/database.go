package database

import (
	"context"
	"fmt"
	"log"
	"os"
	"strconv"
	"sync/atomic"

	"evedem_api/internal/commons"

	"github.com/jackc/pgx/v5"
	_ "github.com/jackc/pgx/v5/stdlib"
	_ "github.com/joho/godotenv/autoload"
)

type DBConn struct {
	DB *pgx.Conn
}

var (
	database                           = os.Getenv("EVERDEEM_DB_DATABASE")
	password                           = os.Getenv("EVERDEEM_DB_PASSWORD")
	username                           = os.Getenv("EVERDEEM_DB_USERNAME")
	port                               = os.Getenv("EVERDEEM_DB_PORT")
	host                               = os.Getenv("EVERDEEM_DB_HOST")
	schema                             = os.Getenv("EVERDEEM_DB_SCHEMA")
	max_connection, max_connection_err = strconv.Atoi(os.Getenv("EVERDEEM_DB_MAX_CONNECTIONS"))
)

var dbconns chan *DBConn
var dbconns_inuse int32 = 0

func ConfigDatabaseConnections() {

	if max_connection_err != nil {
		panic("Envirenment Variable EVERDEEM_DB_MAX_CONNECTIONS Invalid")
	}

	dbconns = make(chan *DBConn, max_connection)
}

func GetDBConn() *DBConn {

	re := &DBConn{}
	if len(dbconns) == 0 && int(dbconns_inuse) < max_connection {
		atomic.AddInt32(&dbconns_inuse, 1)
		re = new()
	} else {
		re = <-dbconns
		atomic.AddInt32(&dbconns_inuse, 1)
	}
	return re
}

func (d *DBConn) Release() {
	atomic.AddInt32(&dbconns_inuse, -1)
	dbconns <- d
}

func new() *DBConn {
	connStr := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable&search_path=%s", username, password, host, port, database, schema)
	db, err := pgx.Connect(context.Background(), connStr)
	if err != nil {
		log.Fatal(err)
	}
	dbInstance := &DBConn{
		DB: db,
	}
	return dbInstance
}

func (s *DBConn) CheckTables() (bool, []string, *commons.ApiError) {

	/* To be set upon final table
	query := ``
	rows, err := s.DB.Query(context.Background(), query)
	if err != nil {
		fmt.Println(err)
		return false, []string{}, &commons.ApiError{
			Error:     commons.ERR_INTERNAL_TRYAGAIN,
			Errorinfo: err,
		}
	}
	defer rows.Close()

	var missing []string
	ok := true
	for rows.Next() {
		ok = false
		if err := rows.Scan(&ok, &missing); err != nil {
			return false, []string{}, &commons.ApiError{
				Error: commons.ERR_INTERNAL_DB_FAIL,
			}
		}
	}
	return ok, missing, nil
	*/
	return true, nil, nil
}

func (s *DBConn) CreateTables() *commons.ApiError {

	query := `
  -- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public."Category"
(
    "categoryId" serial NOT NULL,
    title text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "Category_pkey" PRIMARY KEY ("categoryId")
);

CREATE TABLE IF NOT EXISTS public."Comment"
(
    "commentId" serial NOT NULL,
    "commenterId" integer NOT NULL,
    "productId" integer NOT NULL,
    content text COLLATE pg_catalog."default" NOT NULL,
    date timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT "Comment_pkey" PRIMARY KEY ("commentId")
);

CREATE TABLE IF NOT EXISTS public."Notification"
(
    "notificationId" bigserial NOT NULL,
    "notifiedId" integer NOT NULL,
    content text COLLATE pg_catalog."default" NOT NULL,
    date timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT "Notification_pkey" PRIMARY KEY ("notificationId")
);

CREATE TABLE IF NOT EXISTS public."Order"
(
    "orderId" serial NOT NULL,
    "buyerId" integer NOT NULL,
    status text COLLATE pg_catalog."default" NOT NULL,
    date timestamp with time zone NOT NULL,
    CONSTRAINT "Order_pkey" PRIMARY KEY ("orderId")
);

CREATE TABLE IF NOT EXISTS public."OrderItem"
(
    "orderId" integer NOT NULL,
    "productId" integer NOT NULL,
    quantity integer NOT NULL DEFAULT 0,
    CONSTRAINT "OrderItem_pkey" PRIMARY KEY ("orderId", "productId")
);

CREATE TABLE IF NOT EXISTS public."Product"
(
    "productId" serial NOT NULL,
    "sellerId" integer NOT NULL,
    "categoryId" integer NOT NULL,
    name text COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default" NOT NULL,
    reference text COLLATE pg_catalog."default" NOT NULL,
    picture text COLLATE pg_catalog."default" NOT NULL,
    condition text COLLATE pg_catalog."default" NOT NULL,
    "dateAdded" timestamp with time zone NOT NULL DEFAULT now(),
    price money NOT NULL,
    quantity integer NOT NULL DEFAULT 0,
    color text COLLATE pg_catalog."default" DEFAULT '#FFFFFF'::text,
    height integer NOT NULL DEFAULT 0,
    width integer NOT NULL DEFAULT 0,
    depth integer NOT NULL DEFAULT 0,
    CONSTRAINT "Product_pkey" PRIMARY KEY ("productId")
);

CREATE TABLE IF NOT EXISTS public."Report"
(
    "reportId" serial NOT NULL,
    "reporterId" integer NOT NULL,
    "productId" integer NOT NULL,
    "adminId" integer,
    content text COLLATE pg_catalog."default" NOT NULL,
    date timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT "Report_pkey" PRIMARY KEY ("reportId")
);

CREATE TABLE IF NOT EXISTS public."User"
(
    "userId" serial NOT NULL,
    "firstName" text COLLATE pg_catalog."default" NOT NULL,
    "lastName" text COLLATE pg_catalog."default" NOT NULL,
    "profilPicture" text COLLATE pg_catalog."default",
    email text COLLATE pg_catalog."default" NOT NULL,
    password text COLLATE pg_catalog."default" NOT NULL,
    banned boolean NOT NULL,
    city text COLLATE pg_catalog."default" NOT NULL,
    municipality text COLLATE pg_catalog."default" NOT NULL,
    "postalCode" text COLLATE pg_catalog."default" NOT NULL,
    "bankAccountNumber" text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "User_pkey" PRIMARY KEY ("userId")
);

CREATE TABLE IF NOT EXISTS public.admin
(
    "adminId" serial NOT NULL,
    "userId" integer NOT NULL,
    CONSTRAINT admin_pkey PRIMARY KEY ("adminId"),
    CONSTRAINT "admin_userId_key" UNIQUE ("userId")
);

ALTER TABLE IF EXISTS public."Comment"
    ADD CONSTRAINT "Comment_commenterId_fkey" FOREIGN KEY ("commenterId")
    REFERENCES public."User" ("userId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public."Comment"
    ADD CONSTRAINT "Comment_productId_fkey" FOREIGN KEY ("productId")
    REFERENCES public."Product" ("productId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public."Notification"
    ADD CONSTRAINT "Notification_notifiedId_fkey" FOREIGN KEY ("notifiedId")
    REFERENCES public."User" ("userId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public."Order"
    ADD CONSTRAINT "Order_buyerId_fkey" FOREIGN KEY ("buyerId")
    REFERENCES public."User" ("userId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public."OrderItem"
    ADD CONSTRAINT "OrderItem_orderId_fkey" FOREIGN KEY ("orderId")
    REFERENCES public."Order" ("orderId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public."OrderItem"
    ADD CONSTRAINT "OrderItem_productId_fkey" FOREIGN KEY ("productId")
    REFERENCES public."Product" ("productId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public."Product"
    ADD CONSTRAINT "Product_categoryId_fkey" FOREIGN KEY ("categoryId")
    REFERENCES public."Category" ("categoryId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public."Product"
    ADD CONSTRAINT "Product_sellerId_fkey" FOREIGN KEY ("sellerId")
    REFERENCES public."User" ("userId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public."Report"
    ADD CONSTRAINT "Report_adminId_fkey" FOREIGN KEY ("adminId")
    REFERENCES public.admin ("adminId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public."Report"
    ADD CONSTRAINT "Report_productId_fkey" FOREIGN KEY ("productId")
    REFERENCES public."Product" ("productId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public."Report"
    ADD CONSTRAINT "Report_reporterId_fkey" FOREIGN KEY ("reporterId")
    REFERENCES public."User" ("userId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public.admin
    ADD CONSTRAINT "admin_userId_fkey" FOREIGN KEY ("userId")
    REFERENCES public."User" ("userId") MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;
CREATE INDEX IF NOT EXISTS "admin_userId_key"
    ON public.admin("userId");
CREATE EXTENSION IF NOT EXISTS pgcrypto;

INSERT INTO public."User" ("firstName", "lastName", "profilPicture", email, password, banned, city, municipality, "postalCode", "bankAccountNumber")
VALUES ('Root', 'User', NULL, 'root@everdeem.local', crypt('admin', gen_salt('bf', 8)), FALSE, 'Unknown', 'Unknown', '00000', '00000000000000000000')
ON CONFLICT (email) DO NOTHING; 


INSERT INTO public.admin ("userId")
SELECT "userId"
FROM public."User"
WHERE email = 'root@everdeem.local'
ON CONFLICT ("userId") DO NOTHING;

END;
-----------------------------
--	User Handling
--
CREATE OR REPLACE FUNCTION public.UserCreate(
    p_firstName TEXT,
    p_lastName TEXT,
    p_email TEXT,
    p_password TEXT,
    p_city TEXT,
    p_municipality TEXT,
    p_postalCode TEXT,
    p_bankAccountNumber TEXT,
    p_profilPicture TEXT DEFAULT NULL,
    p_banned BOOLEAN DEFAULT FALSE
)
RETURNS TABLE(created BOOLEAN, newUserId INTEGER)
LANGUAGE plpgsql
AS $$
DECLARE
    v_user_id INTEGER;
BEGIN
    INSERT INTO public."User" (
        "firstName",
        "lastName",
        "profilPicture",
        email,
        password,
        banned,
        city,
        municipality,
        "postalCode",
        "bankAccountNumber"
    ) VALUES (
        p_firstName,
        p_lastName,
        p_profilPicture,
        p_email,
        crypt(p_password, gen_salt('bf')),
        p_banned,
        p_city,
        p_municipality,
        p_postalCode,
        p_bankAccountNumber
    )
    RETURNING "userId" INTO v_user_id;

    RETURN QUERY SELECT TRUE, v_user_id;

EXCEPTION
    WHEN OTHERS THEN
        RETURN QUERY SELECT FALSE, NULL::INTEGER;
END;
$$;
-- Test
/*
SELECT * FROM public.UserCreate(
    p_firstName         => 'AliceUUSUUDJ',
    p_lastName          => 'Wondsddsdserland',
    p_email             => 'alsdsdsice.w@example.com',
    p_password          => 'encrypted_password_hash_123',
    p_city              => 'Curious City',
    p_municipality      => 'Wonder County',
    p_postalCode        => 'WNDR123',
    p_bankAccountNumber => 'BANKACC98765',
    p_profilPicture     => '8732897239023985'
    
);
*/
------------
DROP FUNCTION IF EXISTS public.UserCheck(INTEGER, TEXT, TEXT);
CREATE OR REPLACE FUNCTION public.UserCheck(
    p_userId INTEGER DEFAULT NULL,
    p_email TEXT DEFAULT NULL,
    p_password TEXT DEFAULT NULL
)
RETURNS TABLE (
	userExists BOOLEAN,
	banned BOOLEAN,
	userId INTEGER,
	isAdmin BOOLEAN,
	adminId INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_isAdmin BOOLEAN;
	v_adminId INTEGER;
	v_isBanned BOOLEAN;
    v_stored_password TEXT;
    v_found BOOLEAN := FALSE;
	v_found_id INTEGER;
BEGIN
    IF p_userId IS NULL AND p_email IS NULL THEN
        RETURN QUERY SELECT FALSE, NULL::BOOLEAN, NULL::INTEGER, NULL::BOOLEAN, NULL::INTEGER ;
    END IF;

    SELECT
        u.password,
        a."adminId",
		u."userId",
		u.banned
    INTO
        v_stored_password,
        v_adminId,
		v_found_id,
		v_isBanned
    FROM
        public."User" u
        LEFT JOIN public.admin a ON u."userId" = a."userId"
    WHERE
        (u."userId" = p_userId AND p_userId IS NOT NULL)
        OR (p_userId IS NULL AND u.email = p_email AND p_email IS NOT NULL)
    LIMIT 1;
	v_isAdmin := v_adminId IS NOT NULL;
    IF FOUND THEN
        v_found := TRUE;
		IF v_isBanned IS NOT NULL AND v_isBanned IS TRUE THEN
			v_found 	:= TRUE;
			v_isAdmin 	:= NULL;
			v_isBanned 	:= TRUE;
			v_adminId 	:= NULL;
		ELSE
        	IF p_password IS NOT NULL THEN
        	    IF v_stored_password IS DISTINCT FROM crypt(p_password, v_store_password) THEN
        	        v_found 	:= FALSE;
        	        v_isAdmin 	:= NULL;
					v_found_id	:= NULL;
					v_isBanned 	:= TRUE;
					v_adminId 	:= NULL;
        	    END IF;
        	END IF;
		END IF;
    ELSE
        v_found := FALSE;
        v_isAdmin := NULL;
		v_isBanned := NULL;
		v_found_id := NULL;
		v_adminId 	:= NULL;
    END IF;

    RETURN QUERY SELECT v_found, v_isBanned, v_found_id, v_isAdmin, v_adminId;
END;
$$;
-- Test
/*
SELECT * FROM public.UserCheck(p_email => 'alice.w@example.com');
SELECT * FROM public.UserCheck(
    p_userId => 4,
    p_password => 'encrypted_password_hash_123'
);
SELECT * FROM public.UserCheck(
    p_email => 'alice.w@example.com',
    p_password => 'wrong_encrypted_password_hash'
);
*/
------------
CREATE OR REPLACE FUNCTION public.UserUpdate(
    p_userIdToUpdate INTEGER,
    p_editorId INTEGER,
    p_firstName TEXT DEFAULT NULL,
    p_lastName TEXT DEFAULT NULL,
    p_profilPicture TEXT DEFAULT NULL,
    p_email TEXT DEFAULT NULL,
    p_password TEXT DEFAULT NULL,
    p_banned BOOLEAN DEFAULT NULL,
    p_city TEXT DEFAULT NULL,
    p_municipality TEXT DEFAULT NULL,
    p_postalCode TEXT DEFAULT NULL,
    p_bankAccountNumber TEXT DEFAULT NULL
)
RETURNS TABLE (userExists BOOLEAN, editorAllowed BOOLEAN, updated BOOLEAN)
LANGUAGE plpgsql
AS $$
DECLARE
    v_user_exists BOOLEAN := FALSE;
    v_editor_is_admin BOOLEAN := FALSE;
    v_editor_allowed BOOLEAN := FALSE;
    v_updated BOOLEAN := FALSE;
    v_attempting_ban_change BOOLEAN := FALSE;
BEGIN
    SELECT EXISTS (SELECT 1 FROM public."User" WHERE "userId" = p_userIdToUpdate)
    INTO v_user_exists;

    IF NOT v_user_exists THEN
        RETURN QUERY SELECT FALSE, FALSE, FALSE;
        RETURN;
    END IF;

    SELECT EXISTS (SELECT 1 FROM public.admin WHERE "userId" = p_editorId)
    INTO v_editor_is_admin;

    IF p_editorId = p_userIdToUpdate OR v_editor_is_admin THEN
        v_editor_allowed := TRUE;
    ELSE
        v_editor_allowed := FALSE;
    END IF;

    v_attempting_ban_change := (p_banned IS NOT NULL);

    IF v_editor_allowed AND (NOT v_editor_is_admin) AND v_attempting_ban_change THEN
        RETURN QUERY SELECT v_user_exists, v_editor_allowed, FALSE;
        RETURN;
    END IF;

    IF v_user_exists AND v_editor_allowed THEN
        BEGIN
            UPDATE public."User" SET
                "firstName"         = COALESCE(NULLIF(p_firstName, ''), "firstName"),
                "lastName"          = COALESCE(NULLIF(p_lastName, ''), "lastName"),
                "profilPicture"     = COALESCE(NULLIF(p_profilPicture, ''), "profilPicture"),
                email               = COALESCE(NULLIF(p_email, ''), email),
                password            = COALESCE(NULLIF(crypt(p_password, password), ''), password),
                city                = COALESCE(NULLIF(p_city, ''), city),
                municipality        = COALESCE(NULLIF(p_municipality, ''), municipality),
                "postalCode"        = COALESCE(NULLIF(p_postalCode, ''), "postalCode"),
                "bankAccountNumber" = COALESCE(NULLIF(p_bankAccountNumber, ''), "bankAccountNumber"),
                banned              = COALESCE(p_banned, banned)
            WHERE "userId" = p_userIdToUpdate;

            IF FOUND THEN
                 v_updated := TRUE;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                v_updated := FALSE;
        END;
    END IF;

    RETURN QUERY SELECT v_user_exists, v_editor_allowed, v_updated;
END;
$$;
-- Test
/*
SELECT * FROM public.UserUpdate(
    p_userIdToUpdate := 4,
    p_editorId       := 4,
	p_banned	   	 := TRUE,
    p_city           := 'Wonderland Central',
    p_postalCode     := 'WNDR456'
);
*/
------------
CREATE OR REPLACE FUNCTION public.UserFetch(
    p_userIds INTEGER[],
    p_requesterId INTEGER,
    p_limit INTEGER DEFAULT NULL
)
RETURNS TABLE (
    "requestedUserId" INTEGER,
    found BOOLEAN,
    "isBanned" BOOLEAN,
    "isAdmin" BOOLEAN,   -- New column
    "adminId" INTEGER,   -- New column
    name TEXT,
    "profilPicture" TEXT,
    email TEXT,
    city TEXT,
    municipality TEXT,
    "postalCode" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_requester_is_admin BOOLEAN;
BEGIN
    SELECT EXISTS (SELECT 1 FROM public.admin WHERE "userId" = p_requesterId)
    INTO v_requester_is_admin;

    IF p_userIds IS NULL OR cardinality(p_userIds) = 0 THEN
        RETURN QUERY
        SELECT
            u."userId" AS "requestedUserId",
            TRUE AS found,
            u.banned AS "isBanned",
            CASE WHEN u.banned THEN NULL ELSE (a."adminId" IS NOT NULL) END AS "isAdmin",
            CASE WHEN u.banned THEN NULL WHEN v_requester_is_admin AND a."adminId" IS NOT NULL THEN a."adminId" ELSE NULL END AS "adminId",
            CASE WHEN u.banned THEN NULL ELSE u."firstName" || ' ' || u."lastName" END AS name,
            CASE WHEN u.banned THEN NULL ELSE u."profilPicture" END AS "profilPicture",
            CASE WHEN u.banned THEN NULL WHEN (v_requester_is_admin OR u."userId" = p_requesterId) THEN u.email ELSE NULL END AS email,
            CASE WHEN u.banned THEN NULL WHEN (v_requester_is_admin OR u."userId" = p_requesterId) THEN u.city ELSE NULL END AS city,
            CASE WHEN u.banned THEN NULL WHEN (v_requester_is_admin OR u."userId" = p_requesterId) THEN u.municipality ELSE NULL END AS municipality,
            CASE WHEN u.banned THEN NULL WHEN (v_requester_is_admin OR u."userId" = p_requesterId) THEN u."postalCode" ELSE NULL END AS "postalCode"
        FROM public."User" u
        LEFT JOIN public.admin a ON u."userId" = a."userId" -- Join to check admin status
        ORDER BY u."userId" DESC
        LIMIT p_limit;

    ELSE
        RETURN QUERY
        SELECT
            req.id AS "requestedUserId",
            (u."userId" IS NOT NULL) AS found,
            u.banned AS "isBanned",
            CASE WHEN u."userId" IS NULL OR u.banned THEN NULL ELSE (a."adminId" IS NOT NULL) END AS "isAdmin",
            CASE WHEN u."userId" IS NULL OR u.banned THEN NULL WHEN v_requester_is_admin AND a."adminId" IS NOT NULL THEN a."adminId" ELSE NULL END AS "adminId",
            CASE WHEN u."userId" IS NULL OR u.banned THEN NULL ELSE u."firstName" || ' ' || u."lastName" END AS name,
            CASE WHEN u."userId" IS NULL OR u.banned THEN NULL ELSE u."profilPicture" END AS "profilPicture",
            CASE WHEN u."userId" IS NULL OR u.banned THEN NULL WHEN (v_requester_is_admin OR u."userId" = p_requesterId) THEN u.email ELSE NULL END AS email,
            CASE WHEN u."userId" IS NULL OR u.banned THEN NULL WHEN (v_requester_is_admin OR u."userId" = p_requesterId) THEN u.city ELSE NULL END AS city,
            CASE WHEN u."userId" IS NULL OR u.banned THEN NULL WHEN (v_requester_is_admin OR u."userId" = p_requesterId) THEN u.municipality ELSE NULL END AS municipality,
            CASE WHEN u."userId" IS NULL OR u.banned THEN NULL WHEN (v_requester_is_admin OR u."userId" = p_requesterId) THEN u."postalCode" ELSE NULL END AS "postalCode"
        FROM
            unnest(p_userIds) AS req(id)
            LEFT JOIN public."User" u ON u."userId" = req.id
            LEFT JOIN public.admin a ON u."userId" = a."userId"; -- Join to check admin status
    END IF;

END;
$$;
-- Test
/*
SELECT * FROM public.UserFetch(NULL, 1, 10);

SELECT * FROM public.UserFetch(
	p_userIds     := ARRAY[2, 3, 4, 6], 
	p_requesterId := 4);

SELECT * FROM public.UserFetch(
	p_userIds     := ARRAY[]::INTEGER
	p_requesterId := 4);
*/
------------
CREATE OR REPLACE FUNCTION public.UserPromote(
    p_userIdToPromote INTEGER,
    p_promoterAdminId INTEGER
)
RETURNS TABLE (
    userExists BOOLEAN,
    allowed BOOLEAN,
    "newAdminId" INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_user_exists BOOLEAN := FALSE;
    v_is_already_admin BOOLEAN := FALSE;
    v_admin_table_empty BOOLEAN := FALSE;
    v_promoter_is_authorized BOOLEAN := FALSE;
    v_new_admin_id INTEGER := NULL;
BEGIN
    SELECT EXISTS (SELECT 1 FROM public."User" WHERE "userId" = p_userIdToPromote)
    INTO v_user_exists;

    IF NOT v_user_exists THEN
        RETURN QUERY SELECT FALSE, FALSE, NULL::INTEGER;
        RETURN;
    END IF;

    SELECT EXISTS (SELECT 1 FROM public.admin WHERE "userId" = p_userIdToPromote)
    INTO v_is_already_admin;

    IF v_is_already_admin THEN
        RETURN QUERY SELECT TRUE, FALSE, NULL::INTEGER;
        RETURN;
    END IF;

    SELECT NOT EXISTS (SELECT 1 FROM public.admin LIMIT 1)
    INTO v_admin_table_empty;

    IF v_admin_table_empty THEN
        v_promoter_is_authorized := TRUE;
    ELSE
        SELECT EXISTS (SELECT 1 FROM public.admin WHERE "userId" = p_promoterAdminId)
        INTO v_promoter_is_authorized;
    END IF;

    IF v_promoter_is_authorized THEN
        BEGIN
            INSERT INTO public.admin ("userId")
            VALUES (p_userIdToPromote)
            RETURNING "adminId" INTO v_new_admin_id;

        EXCEPTION
            WHEN OTHERS THEN
                v_promoter_is_authorized := FALSE;
                v_new_admin_id := NULL;
        END;
    END IF;

    RETURN QUERY SELECT TRUE, v_promoter_is_authorized, v_new_admin_id;

END;
$$;
--
-----------------------------
--	Notification Handling
--
DROP FUNCTION notificationfetch(integer,text,text,integer);
CREATE OR REPLACE FUNCTION NotificationFetch(
    p_notified_id INT,
    p_before TEXT DEFAULT NULL,
    p_after TEXT DEFAULT NULL,
    p_limit INT DEFAULT 30
)
RETURNS TABLE (
    notificationId BIGINT,
    content TEXT,
    date TIMESTAMP WITH TIME ZONE
)
AS $$
DECLARE
    v_sql TEXT;
    v_before TIMESTAMP WITH TIME ZONE;
    v_after TIMESTAMP WITH TIME ZONE;
    v_before_adjusted TEXT;
    v_after_adjusted TEXT;
BEGIN

    IF p_before IS NOT NULL THEN
        BEGIN
            IF p_before LIKE '%+%:%' OR p_before LIKE '%-%:%' THEN
                v_before_adjusted := replace(p_before, ':', '');
            ELSE
                v_before_adjusted := p_before;
            END IF;
            v_before := to_timestamp(v_before_adjusted, 'YYYY-MM-DD"T"HH24MISSZ');
        EXCEPTION
            WHEN OTHERS THEN
                RAISE EXCEPTION 'Invalid p_before format. Must be RFC3339 (YYYY-MM-DD"T"HH24:MI:SSZ or YYYY-MM-DD"T"HH24:MI:SS+HHMM).';
        END;
    END IF;

    IF p_after IS NOT NULL THEN
        BEGIN
             IF p_after LIKE '%+%:%' OR p_after LIKE '%-%:%' THEN
                v_after_adjusted := replace(p_after, ':', '');
            ELSE
                v_after_adjusted := p_after;
            END IF;

            v_after := to_timestamp(v_after_adjusted, 'YYYY-MM-DD"T"HH24MISSZ');
        EXCEPTION
            WHEN OTHERS THEN
                RAISE EXCEPTION 'Invalid p_after format. Must be RFC3339 (YYYY-MM-DD"T"HH24:MI:SSZ or YYYY-MM-DD"T"HH24:MI:SS+HHMM).';
        END;
    END IF;

    v_sql := 'SELECT "notificationId", content, date
              FROM "Notification"
              WHERE "notifiedId" = $1';

    IF v_before IS NOT NULL THEN
        v_sql := v_sql || ' AND date < $2';
    END IF;
    IF v_after IS NOT NULL THEN
        v_sql := v_sql || ' AND date > $3';
    END IF;
    v_sql := v_sql || ' ORDER BY date DESC';
    v_sql := v_sql || ' LIMIT $4';


    RETURN QUERY EXECUTE v_sql
    USING p_notified_id, v_before, v_after, p_limit;
END;
$$ LANGUAGE plpgsql;
------------------ 
-- Products
--
DROP FUNCTION IF EXISTS GetCategoryProducts(INT, TIMESTAMPTZ, TIMESTAMPTZ);

CREATE OR REPLACE FUNCTION GetCategoryProducts(
    p_category_id INT,
    p_after       TIMESTAMPTZ DEFAULT NULL,
    p_before      TIMESTAMPTZ DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
AS $$
DECLARE
    category_found BOOLEAN;
    products_json JSON;
BEGIN
    -- Check if the category exists
    SELECT EXISTS (SELECT 1 FROM public."Category" WHERE "categoryId" = p_category_id) INTO category_found;

    IF category_found THEN
        -- Construct the JSON array of products with seller information
        SELECT COALESCE(json_agg(row_to_json(product_info)), '[]'::json)
        INTO products_json
        FROM (
            SELECT
                p."productId",
                p.name AS product_name,
                p.description,
                p.reference,
                p.picture,
                p.condition,
                p."dateAdded",
                p.price,
                p.quantity,
                p.color,      -- Added
                p.height,     -- Added
                p.width,      -- Added
                p.depth,
                CASE
                    WHEN a."adminId" IS NOT NULL THEN 'Evedem Warehouse'
                    ELSE u."firstName" || ' ' || u."lastName"
                END AS seller_name,
                 CASE
                    WHEN a."adminId" IS NOT NULL THEN TRUE
                    ELSE FALSE
                END as is_evedem_warehouse
            FROM public."Product" p
            JOIN public."User" u ON p."sellerId" = u."userId"
            LEFT JOIN public.admin a ON u."userId" = a."userId"
            WHERE p."categoryId" = p_category_id
              AND (p_after IS NULL OR p."dateAdded" > p_after)
              AND (p_before IS NULL OR p."dateAdded" < p_before)
        ) AS product_info;

        RETURN json_build_object('category_found', category_found, 'products', products_json);
    ELSE
        RETURN json_build_object('category_found', FALSE, 'products', '[]'::json);
    END IF;
END;
$$;
  `
	_, err := s.DB.Exec(context.Background(), query)
	if err != nil {
		fmt.Println(err)
		return &commons.ApiError{
			Error:     commons.ERR_INTERNAL_TRYAGAIN,
			Errorinfo: err,
		}
	}

	return nil
}

func (s *DBConn) CreateFunctions() *commons.ApiError {

	/*
		query := ``
		_, err := s.DB.Exec(context.Background(), query)
		if err != nil {
			fmt.Println(err)
			return &commons.ApiError{
				Error:     commons.ERR_INTERNAL_TRYAGAIN,
				Errorinfo: err,
			}
		}
	*/
	return nil
}
